#!/usr/bin/env python3
"""Remove cache and temporary artifacts generated by Show-Scribe."""

from __future__ import annotations

import argparse
import shutil
from pathlib import Path

from show_scribe.config.load import load_config

PROJECT_ROOT = Path(__file__).resolve().parents[2]
EXTRA_CACHE_DIRS = (".pytest_cache", ".mypy_cache", ".ruff_cache")


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Clean cache directories for Show-Scribe.")
    parser.add_argument(
        "--env",
        default="dev",
        help="Configuration environment used to resolve cache directories (default: %(default)s).",
    )
    parser.add_argument(
        "--config-dir",
        type=Path,
        default=None,
        help=(
            "Optional directory containing environment YAML files "
            "(defaults to the repository configs/)."
        ),
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="List the directories that would be removed without deleting them.",
    )
    parser.add_argument(
        "--include-logs",
        action="store_true",
        help="Also clear the logs directory configured in paths.logs_dir.",
    )
    parser.add_argument(
        "--include-model-cache",
        action="store_true",
        help="Clear cached model downloads (useful when forcing re-downloads).",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    config = load_config(args.env, config_dir=args.config_dir, validate=False)

    targets: dict[str, Path] = {
        "cache": resolve_path(config["paths"]["cache_dir"]),
        "temp": resolve_path(config["paths"]["temp_dir"]),
    }

    if args.include_logs:
        targets["logs"] = resolve_path(config["paths"]["logs_dir"])
    if args.include_model_cache:
        targets["models"] = resolve_path(config["paths"]["models_dir"])

    extra_targets = {
        label: PROJECT_ROOT / label for label in EXTRA_CACHE_DIRS if (PROJECT_ROOT / label).exists()
    }

    removed_any = False
    for label, path in {**targets, **extra_targets}.items():
        if not path.exists():
            continue
        removed_any = True
        clear_directory(label, path, dry_run=args.dry_run)

    if not removed_any:
        print("No cache directories found.")
        return

    if args.dry_run:
        print("\nDry run complete. Re-run without --dry-run to apply the cleanup.")


def resolve_path(path_value: str | Path) -> Path:
    """Resolve a possibly relative configuration path."""
    path = Path(path_value)
    if not path.is_absolute():
        path = (PROJECT_ROOT / path).resolve()
    return path


def clear_directory(label: str, path: Path, *, dry_run: bool) -> None:
    """Remove the contents of a directory."""
    if dry_run:
        print(f"[DRY RUN] Would remove contents of {label}: {path}")
        return

    if path.is_file():
        path.unlink()
        print(f"Removed file {path}")
        return

    if path.is_dir():
        for child in path.iterdir():
            if child.is_dir():
                shutil.rmtree(child)
            else:
                child.unlink()
        print(f"Cleared directory {path}")
        return

    print(f"Skipped {path}: unsupported file type.")


if __name__ == "__main__":
    main()
